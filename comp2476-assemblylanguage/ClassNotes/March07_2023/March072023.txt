Data transfers, addressing, and arithmetic

	1. Data transfer instructions
	2. Addition and subtraction
	3. Data-related operators and directives
	4. Indirect addressing
	5. JMP and LOOP instructions
	6. 64-bit programming

	

	Explain why each of the following MOV statements are invalid:
	.data
	bVal	BYTE	100
	bVal2	BYTE	?
	wVal 	WORD	2
	Dval	DWORD	5
	.code
		mov ds, 45		; Invalid MOV statement because ds is a segment register and cannot be loaded with a value. Segment registers hold segment addresses and are typically loaded with values stored in memory.  
		mov esi, wVal	; Invalid MOV statement because esi is a 32-bit register, and wVal is a 16-bit WORD variable. Because of the possible loss of data, we can only move a 16-bit value into a 32-bit register by using zero 
						extension
		mov eip, dVal	; Invalid MOV statement because eip is the instruction pointer register, which cannot be loaded with any value. They are both 32-bit registers. The value of eip is determined by the processor
						during instruction execution, and cannot be modified otherwise. 
		mov 25, bVal	; Invalid MOV statement because the destination operand must be a register or a memory location. The numerical value 25 is not a register or memory location. 
		mo bVal2, bVal	; Invalid MOV statement because of incorrect syntax

	Corrected code:
		.data
		bVal 	BYTE	100
		bVal2	BYTE	?
		wVal	WORD	2
		DvAL	DWORD	5

		.code
		mov ax, 45
		movzx esi, wVal
		mov eip, dVal 
		mov byte ptr[bVal], 25
		mov bVal2, bVal

	
	Zero extension is when you copy a smaller value into a larger destination. The movzx instruction extends the upper half of the destination with zeroes. 
	Example:
		mov bl, 10001111b	; 16 bits
		movzx ax, bl		; zero extension
		=>	value in ax becomes 0000000010001111
	
	Sign extension fills the upper half of the destination with a copy of the source operand's sign bit
	Example:
		mov bl, 10001111b
		movsx ax, bl
		=>	value in ax becomes 1111111110001111


	
	XCHG exchanges the values of two operands. At least one operand must be a register. No immediate operands are permitted. 
	xchg [destination, source]
	.data
		var1 WORD 1000h
		var2 WORD 2000h
	.code
		xchg ax, bx		; Exchange the 16-bit register values
		xchg ah, al		; Exchange the 8-bit register values
		xchg var1, bx	; Exchange the value of bx with var1
		xchg eax, ebx 	; Exchange the 32-bit register values
		xchg var1, var2 ; Two memory operands are used here

	
	A constant offset is added to a data label to produce an effective address. The address is dereferenced to get the value inside its memory location. 
	.data
		arrayB BYTE 10h, 20h, 30h, 40h
	.code
		mov al, arrayB+1
		mov al,[arrayB+1]

	.data
		arrayW WORD 1000h, 2000h, 3000h
		arrayD DWORD 1,2,3,4
	.code
		mov ax,[arrayW+2]
		mov ax,[arrayW+4]
		mov eax,[arrayD+4]
		
	Write a program that rearranges the values of three doubleword values in the following array as: 3,1,2
	.data
		new_array DWORD 11111111h, 22222222h, 33333333h
	.code
		mov eax, [new_array]
		mov ebx [new_array+4]
		mov ecx [new_array+8]

		mov [new_array], ecx
		mov [new_array+4], eax
		mov [new_array+8], ebx




Addition and subtraction:
	Flags affected by arithmetic: Zero, Sign, Carry, Overflow

	INC destination
	DEC destination

	INC and DEC examples:
		.data
			myWord 	WORD	1000h
			myDword	DWORD 	1000000h
		.code
			inc myWord  ; 1001h
			dec myWord  ; 1000h
			inc myDword ; 10000001h

			mov ax, 00FFh
			inc ax			; AX = 0100h
			mov ax, 00FFH
			inc al			; AX = 0000h

	Negation instruction reverses the sign of an operand. An operand can be a register or memory operand. 
	
	.data
	valB BYTE -1
	valW WORD 32767

	.code
	mov al,valB		; AL = -1 
	neg al			; AL = 1
	neg valW		; valW = -32767

	
	neg is implemented internally using: sub 0, operand
	Any nonzero operand causes the carry flag to be set
	Example:
	.data
		valB BYTE 1,0
		valC SBYTE -128
	.code
		neg valB	; CF = 1
		neg [valB+1]; CF = 0
		neg valC	; CF = 1


	HLL compilers translate mathematical expressions into assembly language. For example:
	Rval = -Xval + (Yval - Zval)

	Rval DWORD ?
	Xval DWORD 26
	Yval DWORD 30
	Zval DWORD 40
	.code
		mov eax,Xval
		neg eax			; EAX = -26
		mov ebx,Yval
		sub ebx,Zval	; EBX = -10
		add eax,ebx
		mov Rval,eax	; -36


	Flags affected by arithmetic:
		The arithmetic logic unit has a number of status flags that reflect the outcome of arithmetic (and bitwise) operations based on the contents of the destination operand. 
		Essential flags:
			Zero flag     - Set when destination equals zero
			Sign flag     - Set when destination is negative
			Carry flag    - Set when unsigned value is out of range
			Overflow flag - Set when signed value is out of range		
		A MOV instruction never affects the flags

		Concept map: 
			Arithmetic and bitwise operations affects status flags which are attached to the arithmetic logic unit. The arithmetic logic unit executes arithmetic and bitwise operations. The ALU is part of the CPU, and
		the CPU executes conditional jumps while status flags are used by conditional jumps. Conditional jumps themselves provide branching logic. 


		Example of zero flag set:
			The zero flag is clear when it contains the value 0. It is not clear (set) when it contains the value 1. 
			mov cx,1
			sub cx,1 ; CX = 0, ZF = 1
			mov ax,0FFFFh
			inc ax ; AX = 0, ZF = 1
			inc ax ; AX = 1, ZF = 0
	
		Example of set flag:
			When the destination operand is negative, the sign flag is set. The sign flag is a copy of the destination's highest bit. The flag is set to 0 when the destination is positive. 
			mov cx,0
			sub cx,1 ; CX = -1, SF = 1
			add cx,2 ; CX = 1, SF = 0
			mov al,0
			sub al,1 ; AL = 11111111b, SF = 1
			add al,2 ; AL = 00000001b, SF = 0


	Because the CPU cannot distinguish between signed and unsigned integers, you are responsible for using the correct data type. 

		The Carry flag is set when the result of an operation generates an unsigned value that is out of range (too
		big or too small for the destination operand).
		A subtract operation sets the Carry flag when a larger unsigned integer is subtracted from a smaller one.
	


	For each of the following marked entries, show the value of the destination operand and the Sign, Zero, and Carry flags
		mov ax,00FFh
		add ax,1 ; AX=100 SF=0 ZF =0 CF =0
		sub ax,1 ; AX=00FFh SF =0 ZF =0 CF =0
		add al,1 ; AL=00 SF =0 ZF =1 CF =0
		mov bh,6Ch
		add bh,95h ; BH=02h SF =0 ZF =0 CF =1
		mov al,2
		sub al,3 ; AL=FFh SF =1 ZF =0 CF =1


	The overflow flag is set when the signed result of an operation is invalid or out of range. 
	; Example 1
		mov al,+127
		add al,1 ; OF = 1, AL = 128
			The overflow flag is set because 127 is an 8-bit integer result, which can store a maximum signed value of 127. When try adding 1 to 127, we get an overflow value of 128. AL becomes invalid and does not
		hold an integer result because the addition calculation was invalid. 

		When adding two integers, the overflow is only set when:
			Adding 2 positive integers results in a negative integer
			Adding 2 negative integers results in a positive integer

	


Data-related operators and directives:
	OFFSET, PTR, TYPE, LENGTHOF, SIZEOF, LABEL

	Offset returns the distance in bytes from the start to end of its current segment in memory. In real mode that offset can be 16 bits in size, and in protected mode can be 32 bits in size. 