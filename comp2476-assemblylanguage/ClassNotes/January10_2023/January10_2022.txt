Brief overview: 
	Assembly-level machine organization
	Memory system organization and architecture
	Writing simple I/O routines and interrupt handlers
	Introduction to initialization and process management in a Unix or Unix-like operating system 


Software tools
	Visual Studio 2019/22
	MASM (Microsoft Assembler)
	NASM (Netwide Assembler)


1. Basic concepts
2. Processor architecture
3. Assembly langueg fundamentals
4. Data transfer addressing and arithmetic
5. Procedures
6. Condition processing
7. Integer arithmetic
8. Advanced procedures
9. Process management
10. Processes and threads



Basic concepts of assembly and computer systems:
	i) Welcome to assembly language ii) Virtual machine concept iii) Data representation iv) Boolean operations

	int y;
	int x = (y + 4) * 3

	mov eax, y			; Move y to the eax register
	add eax, 4			; Add 4 to the eax register
	mov ebx, 3			; Move 3 to the ebx register
	imul ebx			; Multiply eax by ebx
	mov x, eax			; Move eax to x

Each computer has a native machine language L0 that runs directly on the hardware
A more human-friendly language is usually constructed above machine language, called L1

Interpretation - L0 program interprets and executes L1 instructions one-by-one
Translation - L1 program is completely translated into an L0 program, which then runs on the computer hardware




English: Display the sum of A times B plus C

C++: cout << (A * B + C);

Assembly:
	mov eax, A
	mul B
	add eax, C
	call WriteInt

Intel Machine Language:
	A1 00000000
	F7 25 00000004
	..
	..


Specific machine levels
	Virtual machine VM1
	Virtual machine VM2


	Level 4 
		High-level language
		
		Application oriented language:
			C++, Java, Pascal, Visual Basic, etc.
		Programs compile into assembly language
	Level 3
		Assembly language
		
		Instruction mnemonics that have a one-to-one correspondence to machine language
		Programs are translated into instruction set architecture level - machine language (level 2)
	Level 2
		Instruction set architecture (ISA)
		Conventional machine language
		Executed by level 1 (Digital logic).
	Level 1
		CPU, constructed from digital logic gates
		Digital logic
		System bus
		Memory
		Implemented using bipolar transistor




	
Learn how to do the following:
	Form the two's complement of a hexadecimal integer:
		Suppose we have 1C5. First, we need to convert this number to decimal by doing the following operations: (5 * 16^0) + (C * 16^1) + (1 * 16^2). Then, we will continuously do operations which divide that number by 2 
		until the quotient will be less than 1. For each division step, use the quotient from the previous division operation. Arrange the binary number from the digits bottom-to-top. Finally, to store the number in
		two's complement format, we will reverse all the bits and add 1 to the reversed bits. 

	Convert signed binary to decimal:
		Let's suppose we have 110011. For each n digits in the binary number, with the current m digit selected, we take the sum of all the terms such that: sum = (m1 + 2^n1) + ... + (m + 2^n)
		sum (from LSB to MSB) = (1 * 2^0) + (1 * 2^1) + (0 * 2^2) + (0 * 2^3) + (1 * 2^4) + (1 * 2^5) = 51

	Convert signed decimal to binary: 
		Let's suppose we want to convert 51 into binary. To do this, we would do the repeated division technique by repeatedly dividing on the first step the number itself by 2, and on subsequent steps the quotient by 2. 
		We also store the remainder of each division result. Once we can no longer divide the number to avoid getting a quotient of less than 1, we add up the binary digits into a binary number in reverse order to how we
		got the remainders. 

	Convert decimal to hexadecimal:
		This process is the exact same steps as the division by 2, except that we are using division by 16 because a hexadecimal number is a base of 16. The remainder can be anywhere between 0 (0) and 15 (F). If the remainders
		lie between 10 and 15, you have to convert those numbers into their equivalent hexadecimal values (10, 11, 12, 13, 14, 15) -> (A, B, C, D, E, F).

	Convert signed hexadecimal to decimal:
		For each n digits in the hexadecimal number, with the current m digit selected, we take the sum of all the terms such that: sum = (m1 + 16^n1) + ... + (m + 16^n). You must convert all hexadecimal letters (A - F) to ints
		sum (from LSB to MSB) of 1C5: (1 * 16^2) + (12 * 16^1) + (5 * 16^0) = 453. 
	

		